#!/usr/bin/perl
## ----------------------------------------------------------------------------
# cil is a Command line Issue List
# Copyright (C) 2008 Andrew Chilton
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
## ----------------------------------------------------------------------------

use strict;
use warnings;

use Data::Dumper;

use Digest::MD5 qw(md5_hex);
use File::Touch;
use File::Glob ':glob';
use File::Basename;
use File::Slurp qw(read_file write_file);
use Term::CallEditor qw(solicit);
use CIL;
use CIL::Issue;
use CIL::Comment;
use CIL::Attachment;

my $COMMANDS = {
    init    => 1,
    list    => 1,
    summary => 1,
    add     => 1,
    show    => 1,
    edit    => 1,
    comment => 1,
    attach  => 1,
    extract => 1,
};

my $gan = $ENV{GIT_AUTHOR_NAME} || 'Your Name';
my $gae = $ENV{GIT_AUTHOR_EMAIL} || 'you@example.org';

my $new_issue_text = <<"EOF";
Summary     : 
Status      : New
CreatedBy   : $gan <$gae>
AssignedTo  : $gan <$gae>
Label       : 

Description...
EOF

my $add_comment_text = <<"EOF";
CreatedBy   : $gan <$gae>

Description...
EOF

## ----------------------------------------------------------------------------

{
    my ($command) = shift;
    unless ( defined $command and exists $COMMANDS->{$command} ) {
        usage();
        exit 2;
    }

    my $cil = CIL->new();

    if ( $command eq 'init' ) {
        my ($path) = @ARGV;
        $path ||= '.';
        init($cil, $path);

    }
    elsif ( $command eq 'list' ) {
        list($cil);

    }
    elsif ( $command eq 'summary' ) {
        summary($cil);

    }
    elsif ( $command eq 'show' ) {
        my ($issue_name) = @ARGV;
        show($cil, $issue_name);

    }
    elsif ( $command eq 'add' ) {
        add($cil);

    }
    elsif ( $command eq 'edit' ) {
        my ($issue_name) = @ARGV;
        edit($cil, $issue_name);

    }
    elsif ( $command eq 'comment' ) {
        my ($issue_name) = @ARGV;
        comment($cil, $issue_name);

    }
    elsif ( $command eq 'attach' ) {
        my ($issue_name, $filename) = @ARGV;
        attach($cil, $issue_name, $filename);

    }
    elsif ( $command eq 'extract' ) {
        my ($issue_name, $attachment_name, $filename) = @ARGV;
        extract($cil, $issue_name, $attachment_name, $filename);

    }

    else {
        fatal("program error when trying command '$command'");
    }

}

## ----------------------------------------------------------------------------
# commands

sub init {
    my ($cil, $path) = @_;

    # error if $path doesn't exist
    unless ( -d $path ) {
        fatal("path '$path' doesn't exist");
    }

    # error if issues/ already exists
    my $issues_dir = "$path/issues";
    if ( -d $issues_dir ) {
        fatal("issues directory '$issues_dir' already exists, not initialising issues");
    }

    # error if .cil already exists
    my $config = "$path/.cil";
    if ( -f $config ) {
        fatal("config file '$config' already exists, not initialising issues");
    }

    # try to create the issues/ dir
    unless ( mkdir $issues_dir ) {
        fatal("Couldn't create '$issues_dir' directory: $!");
    }

    # create a .cil file here also
    unless ( touch $config ) {
        rmdir $issues_dir;
        fatal("couldn't create a '$config' file");
    }

    # $path/issues/ and $path/.cil create correctly
    msg("initialised empty issue list inside '$path/'");
}

sub list {
    my ($cil) = @_;

    check_paths($cil);

    # find all the issues
    my $issues = $cil->get_issues();
    if ( @$issues ) {
        foreach my $issue ( sort { $a->Inserted cmp $b->Inserted } @$issues ) {
            separator();
            display_issue_headers($cil, $issue);
        }
        separator();
    }
    else {
        msg('no issues found');
    }
}

sub summary {
    my ($cil) = @_;

    check_paths($cil);

    # find all the issues
    my $issues = $cil->get_issues();
    if ( @$issues ) {
        separator();
        foreach my $issue ( @$issues ) {
            display_issue_summary($cil, $issue);
        }
        separator();
    }
    else {
        msg('no issues found');
    }
}

sub show {
    my ($cil, $issue_name) = @_;

    # firstly, read the issue in
    my $issue = CIL::Issue->new_from_name($cil, $issue_name);
    unless ( defined $issue ) {
        fatal("Couldn't load issue '$issue_name'");
    }
    display_issue_full($cil, $issue);
}

sub add {
    my ($cil, $issue_name) = @_;

    # read in the new issue text
    my $fh = solicit( $new_issue_text );

    my $issue = CIL::Issue->new_from_fh( 'tmp', $fh );

    # we've got the issue, so let's name it
    my $unique_str = $issue->Inserted . $issue->Summary . $issue->Description;
    $issue->set_name( substr(md5_hex($unique_str), 0, 8) );
    $issue->save($cil);
    display_issue($cil, $issue);
}

sub edit {
    my ($cil, $issue_name) = @_;

    my $issue = CIL::Issue->new_from_name($cil, $issue_name);
    unless ( defined $issue ) {
        fatal("Couldn't load issue '$issue_name'");
    }

    # create the ini file, then edit it
    my $edit_issue_text = $issue->as_output;

    # read in the new issue text
    my $fh = solicit( join('', @$edit_issue_text) );

    my $issue_edited = CIL::Issue->new_from_fh( $issue->name, $fh );
    unless ( defined $issue_edited ) {
        fatal("couldn't create issue (program error)");
    }

    $issue_edited->save($cil);
    display_issue($cil, $issue_edited);
}

sub comment {
    my ($cil, $issue_name) = @_;

    my $issue = CIL::Issue->new_from_name($cil, $issue_name);
    unless ( defined $issue ) {
        fatal("couldn't load issue '$issue_name'");
    }

    # read in the new issue text
    my $fh = solicit( $add_comment_text );

    my $comment = CIL::Comment->new_from_fh( 'tmp', $fh );
    unless ( defined $comment ) {
        fatal("could not create new comment");
    }

    # we've got the comment, so let's name it
    my $unique_str = $comment->Inserted . $issue->Description;
    $comment->set_name( substr(md5_hex($unique_str), 0, 8) );

    # finally, tell it who it's parent is and then save
    $comment->Issue( $issue->name );
    $comment->save($cil);

    # add the comment to the issue, update it's timestamp and save it out
    $issue->add_comment( $comment );
    $issue->save($cil);
    display_issue_full($cil, $issue);
}

sub attach {
    my ($cil, $issue_name, $filename) = @_;

    my $issue = CIL::Issue->new_from_name($cil, $issue_name);
    unless ( defined $issue ) {
        fatal("couldn't load issue '$issue_name'");
    }

    # check to see if the file exists
    unless ( -r $filename ) {
        fatal("couldn't read file '$filename'");
    }

    my $basename = basename( $filename );

    my $add_attachment_text = <<"EOF";
Filename    : $basename
CreatedBy   : $gan <$gae>

File goes here ... this will be overwritten.
EOF

    # read in the new issue text
    my $fh = solicit( $add_attachment_text );

    my $attachment = CIL::Attachment->new_from_fh( 'tmp', $fh );
    unless ( defined $attachment ) {
        fatal("could not create new attachment");
    }

    # now add the file itself
    my $contents = read_file( $filename );
    $attachment->set_file_contents( $contents );

    # set the size
    my ($size) = (stat($filename))[7];
    $attachment->Size( $size );

    # we've got the attachment, so let's name it
    my $unique_str = $attachment->Inserted . $attachment->File;
    $attachment->set_name( substr(md5_hex($unique_str), 0, 8) );

    # finally, tell it who it's parent is and then save
    $attachment->Issue( $issue->name );
    $attachment->save($cil);

    # add the comment to the issue, update it's timestamp and save it out
    $issue->add_attachment( $attachment );
    $issue->save($cil);
    display_issue_full($cil, $issue);
}

sub extract {
    my ($cil, $attachment_name, $filename) = @_;

    my $attachment = CIL::Attachment->new_from_name($cil, $attachment_name);
    unless ( defined $attachment ) {
        fatal("Couldn't load attachment '$attachment_name'");
    }

    $filename ||= $attachment->Filename();
    write_file( $filename, $attachment->as_binary );
}

## ----------------------------------------------------------------------------

sub check_paths {
    my ($cil) = @_;

    # make sure an issue directory is available
    unless ( -d $cil->issue_dir ) {
        fatal("couldn't find '" . $cil->issue_dir . "' directory");
    }
}

## ----------------------------------------------------------------------------
# input/output

sub display_issue_summary {
    my ($cil, $issue) = @_;

    my $msg = $issue->name();
    $msg .= "\t";
    $msg .= $issue->Status();
    $msg .= "\t";
    $msg .= $issue->Summary();

    msg($msg);
}

sub display_issue_headers {
    my ($cil, $issue) = @_;

    title( 'Issue ' . $issue->name() );
    field( 'Summary', $issue->Summary() );
    field( 'CreatedBy', $issue->CreatedBy() );
    field( 'AssignedTo', $issue->AssignedTo() );
    field( 'Inserted', $issue->Inserted() );
    field( 'Status', $issue->Status() );
    field( 'Labels', join(' ', @{$issue->Label()}) );
}

sub display_issue {
    my ($cil, $issue) = @_;

    separator();
    title( 'Issue ' . $issue->name() );
    field( 'Summary', $issue->Summary() );
    field( 'Status', $issue->Status() );
    field( 'CreatedBy', $issue->CreatedBy() );
    field( 'AssignedTo', $issue->AssignedTo() );
    field( 'Label', $_ )
        foreach sort @{$issue->Label()};
    field( 'Comment', $_ )
        foreach sort @{$issue->Comment()};
    field( 'Attachment', $_ )
        foreach sort @{$issue->Attachment()};
    field( 'Inserted', $issue->Inserted() );
    field( 'Updated', $issue->Inserted() );
    text('Description', $issue->Description());
    separator();
}

sub display_issue_full {
    my ($cil, $issue) = @_;

    separator();
    title( 'Issue ' . $issue->name() );
    field( 'Summary', $issue->Summary() );
    field( 'Status', $issue->Status() );
    field( 'CreatedBy', $issue->CreatedBy() );
    field( 'AssignedTo', $issue->AssignedTo() );
    field( 'Label', $_ )
        foreach sort @{$issue->Label()};
    field( 'Inserted', $issue->Inserted() );
    field( 'Updated', $issue->Inserted() );
    text('Description', $issue->Description());

    my $comments = $cil->get_comments_for( $issue );
    foreach my $comment ( @$comments ) {
        title( 'Comment ' . $comment->name() );
        field( 'CreatedBy', $comment->CreatedBy() );
        field( 'Inserted', $comment->Inserted() );
        field( 'Updated', $comment->Inserted() );
        text('Description', $comment->Description());
    }

    my $attachments = $cil->get_attachments_for( $issue );
    print Dumper();
    foreach my $attachment ( @$attachments ) {
        title( 'Attachment ' . $attachment->name() );
        field( 'Filename', $attachment->Filename() );
        field( 'CreatedBy', $attachment->CreatedBy() );
        field( 'Inserted', $attachment->Inserted() );
        field( 'Updated', $attachment->Inserted() );
        msg();
    }

    separator();
}

sub msg {
    print ( defined $_[0] ? $_[0] : '' );
    print "\n";
}

sub separator {
    msg('=' x 79);
}

sub title {
    my ($title) = @_;
    my $msg = "--- $title ";
    $msg .= '-' x (74 - length($title));
    msg($msg);
}

sub field {
    my ($field, $value) = @_;
    my $msg = "$field";
    $msg .= " " x (12 - length($field));
    msg("$msg: " . (defined $value ? $value : '') );
}

sub text {
    my ($field, $value) = @_;
    msg "";
    msg($value);
    msg "";
}

sub err {
    print STDERR ( defined $_[0] ? $_[0] : '' );
    print STDERR "\n";
}

sub fatal {
    my ($msg) = @_;
    chomp $msg;
    print STDERR $msg, "\n";
    exit 2;
}

## ----------------------------------------------------------------------------
# program info

sub usage {
   print <<"END_USAGE";
Usage: $0 COMMAND [options]

Commands:
   init    PATH
   add
   summary
   list
   show    ISSUE
   edit    ISSUE
   comment ISSUE
   attach  ISSUE FILENAME
   extract ATTACHMENT [TO_FILENAME]

See <http://kapiti.geek.nz/software/cil.html> for further information.
Report bugs to <andychilton -at- gmail -dot- com>.
END_USAGE
}

## ----------------------------------------------------------------------------
